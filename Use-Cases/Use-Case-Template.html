<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Use Case Template</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
<style>
:root{--border:#bdbdbd;--text:#333;--muted:#666;--bg:#f9f9f9;--white:#fff;--header:#e0e0e0;}
body{font:16px Arial;margin:20px auto;padding:20px;max-width:1200px;background:var(--bg);color:var(--text);border:2px solid #ccc;}
h1{text-align:center;margin:0 0 18px;}
.description{text-align:center;color:var(--muted);margin-bottom:24px;}
.export-buttons{display:flex;justify-content:center;flex-wrap:wrap;gap:10px;margin:0 0 18px;}
.export-buttons button{padding:10px 16px;min-width:120px;border:none;border-radius:4px;background:#000;color:#fff;cursor:pointer;font-weight:700;transition:opacity .15s ease;}
.export-buttons button:hover{opacity:.85;}
table{width:100%;border-collapse:collapse;background:var(--white);box-shadow:0 2px 4px rgba(0,0,0,.08);font-size:14px;}
th,td{border:1px solid var(--border);padding:12px;vertical-align:top;word-wrap:break-word;}
th{background:#f0f0f0;text-align:left;}
tr:nth-child(even) td:not(.category){background:#fafafa;}
.category{background:var(--header);font-weight:700;text-transform:uppercase;text-align:center;}
.note{font-size:13px;color:var(--muted);margin-top:12px;}
@media (max-width:768px){body{margin:10px;padding:14px;}.export-buttons{gap:8px;}.export-buttons button{width:100%;max-width:260px;}table{display:block;overflow-x:auto;white-space:nowrap;font-size:12px;}th,td{padding:8px;min-width:140px;}}
@media print{.export-buttons{display:none;}body{border:none;margin:0;padding:8px;}}
</style>
</head>
<body>
<h1 id="pageTitle">Use Case Template</h1>
<p class="description" id="pageDescription">Dynamic use case template driven by JSON data</p>
<div class="export-buttons">
  <button onclick="exportUseCaseToCSV()">Export Use Case (CSV)</button>
  <button onclick="exportUseCaseToPDF()">Export Use Case (PDF)</button>
  <button onclick="window.print()">Print</button>
</div>
<div id="useCaseTableContainer"></div>
<script>
const useCaseData = {
  title: "Use Case: UC-1 – Employee Submits Vacation Request",
  description: "Compact use case template with actors in the summary, rules before deviations, and qualities merged into validation rules.",
  sections: {
    Summary: [
      ["ID", "UC-1"],
      ["Name", "Employee Submits Vacation Request"],
      ["Goal", "Allow an employee to submit a vacation request and route it to the manager for approval."],
      ["Scope", "HR Self-Service Portal"],
      ["Actors", "Employee (primary), Manager (secondary), HR System (supporting)"]
    ],
    Triggers: [
      ["Trigger", "Employee initiates a new vacation request in the portal."]
    ],
    "Pre-Conditions": [
      "Employee is authenticated in the HR system.",
      "Employee has a non-zero leave balance."
    ],
    "Basic Flow (Main Success Scenario)": {
      headers: ["#", "User Action", "System Response"],
      rows: [
        ["1", "Employee navigates to \"Request Vacation\".", "System displays the vacation request form."],
        ["2", "Employee enters start date, end date, and reason.", "System validates dates in real-time and shows current leave balance."],
        ["3", "Employee clicks \"Submit\".", "System saves request, assigns a Request ID, and routes to the Manager."],
        ["4", "—", "Manager receives a notification for pending approval."]
      ]
    },
    "Business Validation Rules": {
      headers: ["Rule ID", "Description", "Condition", "Message ID", "Notes"],
      rows: [
        ["BV-001", "End date must be strictly aftear start date.", "endDate > startDate", "MSG-101", "Validated client & server."],
        ["BV-002", "Requested days must not exceed available leave balance.", "daysRequested ≤ leaveBalance", "MSG-102", "Override requires HR approval."],
        ["BV-003", "Sick leave requires a medical certificate attachment.", "type == \"Sick\"", "MSG-103", "Attachment is mandatory."],
        ["BV-004", "Submission should complete quickly for good UX.", "submissionTime ≤ 120s", "N/A", "Performance/quality constraint."]
      ]
    },
    "Exceptions (Error Conditions)": {
      headers: ["ID", "At Step", "Issue", "Resolution"],
      rows: [
        ["EX-1", "Step 2", "Insufficient leave balance.", "System blocks submission and displays an error."],
        ["EX-2", "Step 3", "HR database unavailable.", "System shows error, logs incident, and asks to retry later."]
      ]
    },
    "Alternate Flows (Optional Variations)": {
      headers: ["ID", "At/From Step", "Description", "Outcome / Resolution"],
      rows: [
        ["AF-1", "Step 2", "Employee selects dates overlapping an existing request.", "System warns and allows confirm-or-adjust."],
        ["AF-2", "Step 3", "Employee cancels before submission.", "System discards input and returns to dashboard."]
      ]
    },
    "Post-Conditions": [
      "Request stored with status \"Pending Approval\".",
      "Manager notified; can approve or reject.",
      "Employee can track status from dashboard."
    ],
    "Notes": [
      ["Note", "All details consolidated in a single table for consistency and easy export/printing."]
    ]
  }
};
function renderUseCaseTable(data) {
  const container = document.getElementById('useCaseTableContainer');
  container.innerHTML = '';
  
  document.getElementById('pageTitle').textContent = data.title;
  document.getElementById('pageDescription').textContent = data.description;
  
  
  let maxColumns = 5; 
  
  
  Object.values(data.sections).forEach(content => {
    if (content.headers) {
      maxColumns = Math.max(maxColumns, content.headers.length);
    }
  });
  
  const table = document.createElement('table');
  table.setAttribute('aria-label', `Use Case ${data.title}`);
  const tbody = document.createElement('tbody');
  
  
  Object.entries(data.sections).forEach(([title, content]) => {
const headerRow = document.createElement('tr');
    const headerCell = document.createElement('td');
    headerCell.className = 'category';
    headerCell.colSpan = maxColumns;
    headerCell.textContent = title;
    headerRow.appendChild(headerCell);
    tbody.appendChild(headerRow);
    if (Array.isArray(content)) {
  
  content.forEach(item => {
        const tr = document.createElement('tr');
    
    if (Array.isArray(item)) {
      
      const keyCell = document.createElement('td');
          keyCell.textContent = item[0];
      
      keyCell.colSpan = Math.max(1, Math.floor(maxColumns * 0.2));
          tr.appendChild(keyCell);
      
      const valueCell = document.createElement('td');
          valueCell.colSpan = maxColumns - keyCell.colSpan;
          valueCell.textContent = item[1];
          tr.appendChild(valueCell);
        } else {
      
      const numCell = document.createElement('td');
          numCell.textContent = content.indexOf(item) + 1;
      
      numCell.colSpan = Math.max(1, Math.floor(maxColumns * 0.1));
          tr.appendChild(numCell);
      
      const valueCell = document.createElement('td');
          valueCell.colSpan = maxColumns - numCell.colSpan;
          valueCell.textContent = item;
          tr.appendChild(valueCell);
        }
    
    tbody.appendChild(tr);
      });
    } else if (content.headers && content.rows) {
  
  const headerRow = document.createElement('tr');
  
  
      const colDistribution = calculateColumnDistribution(content, maxColumns);
  
  content.headers.forEach((header, i) => {
        const th = document.createElement('th');
        th.textContent = header;
        th.colSpan = colDistribution[i] || 1;
        headerRow.appendChild(th);
      });
  
  tbody.appendChild(headerRow);
  
  
      content.rows.forEach(row => {
        const tr = document.createElement('tr');
    
    row.forEach((cell, i) => {
          const td = document.createElement('td');
          td.textContent = cell;
          td.colSpan = colDistribution[i] || 1;
          tr.appendChild(td);
        });
    
    if (row.length < content.headers.length) {
          const lastCell = tr.cells[tr.cells.length - 1];
          let remainingColspan = 0;
      
      for (let i = row.length; i < content.headers.length; i++) {
            remainingColspan += colDistribution[i] || 1;
          }
      
      lastCell.colSpan += remainingColspan;
        }
    
    tbody.appendChild(tr);
      });
    }
  });
  
  table.appendChild(tbody);
  container.appendChild(table);
}
function calculateColumnMetrics(content, columnIndex) {
  if (!content || !content.headers || !content.rows) {
    return { avgLength: 0, maxLength: 0, variance: 0 };
  }
  const header = content.headers[columnIndex];
  const cellLengths = content.rows.map(row => {
    const cell = row[columnIndex];
    return cell ? cell.toString().length : 0;
  });
  
  cellLengths.push(header.length * 0.2);
  
  const avgLength = cellLengths.reduce((sum, len) => sum + len, 0) / cellLengths.length;
  
  const variance = cellLengths.reduce((sum, len) => {
    const diff = len - avgLength;
    return sum + (diff * diff);
  }, 0) / cellLengths.length;
  
  const maxLength = Math.max(...cellLengths);
  return { avgLength, maxLength, variance };
}
function normalizeToSpans(values, totalSpan, minSpan = 1, maxSpanRatio = 0.4) {
  const total = values.reduce((sum, v) => sum + v, 0);
  const maxSpan = Math.floor(totalSpan * maxSpanRatio);
  
  
  let spans = values.map(v => {
    const rawSpan = (v / total) * totalSpan;
    return Math.max(minSpan, Math.min(maxSpan, Math.round(rawSpan)));
  });
  
  let currentTotal = spans.reduce((sum, span) => sum + span, 0);
  
  while (currentTotal !== totalSpan) {
    const diff = totalSpan - currentTotal;
    if (diff > 0) {
  
  const idx = values
        .map((v, i) => ({ value: v, index: i }))
        .filter(({ index }) => spans[index] < maxSpan)
        .sort((a, b) => b.value - a.value)[0]?.index;
  
  if (idx !== undefined) spans[idx]++;
    } else {
  
  const idx = values
        .map((v, i) => ({ value: v, index: i }))
        .filter(({ index }) => spans[index] > minSpan)
        .sort((a, b) => a.value - b.value)[0]?.index;
  
  if (idx !== undefined) spans[idx]--;
    }
    currentTotal = spans.reduce((sum, span) => sum + span, 0);
  }
  return spans;
}
function calculateColumnDistribution(content, maxColumns) {
  if (!content || !content.headers || !content.rows) {
    return Array(maxColumns).fill(1);
  }
  const totalColumns = content.headers.length;
  
  
  const columnMetrics = content.headers.map((_, idx) => 
    calculateColumnMetrics(content, idx)
  );
  
  const weights = columnMetrics.map(metrics => {
    const { avgLength, variance } = metrics;
    const baseWeight = avgLength;
    const variancePenalty = Math.max(0.8, 1 - Math.sqrt(variance) / 100);
    return Math.max(5, baseWeight) * variancePenalty;
  });
  
  const minSpan = 1;
  const maxSpanRatio = calculateMaxSpanRatio(columnMetrics, totalColumns);
  
  
  return normalizeToSpans(weights, maxColumns, minSpan, maxSpanRatio);
}
function calculateMaxSpanRatio(metrics, totalColumns) {
  
  const baseMaxRatio = 1 / totalColumns;
  
  
  const maxAvgLength = Math.max(...metrics.map(m => m.avgLength));
  const minAvgLength = Math.min(...metrics.map(m => m.avgLength));
  
  
  const lengthRatio = maxAvgLength / (minAvgLength || 1);
  
  
  const scaledRatio = baseMaxRatio * (1 + Math.min(3, lengthRatio / 2));
  
  return Math.min(0.6, Math.max(0.25, scaledRatio));
}
function exportSectionAsCSV() {
  const table = document.querySelector('table');
  const headerCell = Array.from(table.querySelectorAll('.category'))
    .find(cell => cell.textContent.trim().toLowerCase().includes('business validation rules'));
  
  if (!headerCell) { alert('Business Rules section not found.'); return; }
  const startRow = headerCell.parentElement.rowIndex + 1;
  const rows = [];
  const trs = table.rows;
  
  for (let i = startRow; i < trs.length; i++) {
    const tr = trs[i];
    const firstCell = tr.cells[0];
    if (firstCell && firstCell.classList.contains('category')) break;
    if (tr.cells.length && tr.cells[0].tagName === 'TH') continue;
    rows.push(Array.from(tr.cells).map(td => td.textContent.replace(/\s+/g, ' ').trim()));
  }
  const csv = rows.map(r => r.map(v => /[",\n]/.test(v) ? `"${v.replace(/"/g, '""')}"` : v).join(',')).join('\n');
  const blob = new Blob([csv], {type: 'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'business-rules.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function exportUseCaseToCSV() {
    const sections = [];
    
    // Add title and description
    sections.push(['Title', useCaseData.title]);
    sections.push(['Description', useCaseData.description]);
    sections.push([]);  // Empty line for separation
    
    // Process each section
    Object.entries(useCaseData.sections).forEach(([sectionTitle, content]) => {
        sections.push([sectionTitle.toUpperCase()]);
        
        if (Array.isArray(content)) {
            content.forEach(item => {
                if (Array.isArray(item)) {
                    sections.push([item[0], item[1]]);
                } else {
                    sections.push(['•', item]);
                }
            });
        } else if (content.headers && content.rows) {
            sections.push(content.headers);
            content.rows.forEach(row => sections.push(row));
        }
        sections.push([]); // Empty line between sections
    });

    const csv = sections.map(row => 
        row.map(cell => 
            cell ? `"${cell.toString().replace(/"/g, '""')}"` : ''
        ).join(',')
    ).join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'use-case.csv';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
}

function exportUseCaseToPDF() {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF({
        orientation: 'portrait',
        unit: 'pt',
        format: 'a4'
    });

    doc.setProperties({
        title: useCaseData.title,
        subject: useCaseData.description,
        author: 'Use Case Generator',
        creator: 'Use Case Generator'
    });

    const margin = 20;
    const pageWidth = doc.internal.pageSize.width;
    const contentWidth = pageWidth - (margin * 2);

    // Common table styles
    const tableDefaults = {
        styles: {
            fontSize: 8,
            cellPadding: 3,
            lineWidth: 0.1,
            lineColor: [189, 189, 189]
        },
        margin: { left: margin, right: margin },
        theme: 'grid'
    };

    // Title and description table
    doc.autoTable({
        startY: margin,
        head: [[{
            content: useCaseData.title,
            styles: { halign: 'center', fontStyle: 'bold' }
        }]],
        body: [[{
            content: useCaseData.description,
            styles: { halign: 'center' }
        }]],
        ...tableDefaults
    });

    let yPos = doc.lastAutoTable.finalY + 5;

    // Process each section
    Object.entries(useCaseData.sections).forEach(([sectionTitle, content]) => {
        // Section Header
        doc.autoTable({
            startY: yPos,
            body: [[{
                content: sectionTitle,
                styles: {
                    fillColor: [224, 224, 224],
                    fontStyle: 'bold',
                    halign: 'center',
                    textTransform: 'uppercase'
                }
            }]],
            ...tableDefaults
        });
        yPos = doc.lastAutoTable.finalY;

        if (Array.isArray(content)) {
            if (content.length > 0 && Array.isArray(content[0])) {
                // Key-value pairs
                doc.autoTable({
                    startY: yPos,
                    body: content.map(([key, value]) => [{
                        content: key,
                        styles: { cellWidth: 100 }
                    }, value]),
                    columnStyles: {
                        0: { fillColor: [250, 250, 250] }
                    },
                    ...tableDefaults
                });
            } else {
                // Bullet list
                doc.autoTable({
                    startY: yPos,
                    body: content.map(item => [item]),
                    ...tableDefaults
                });
            }
        } else if (content.headers && content.rows) {
            // Tables with headers
            doc.autoTable({
                startY: yPos,
                head: [content.headers],
                body: content.rows,
                headStyles: {
                    fillColor: [240, 240, 240],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold'
                },
                alternateRowStyles: {
                    fillColor: [250, 250, 250]
                },
                ...tableDefaults
            });
        }
        yPos = doc.lastAutoTable.finalY + 2;
    });

    // Add page numbers
    const pageCount = doc.internal.getNumberOfPages();
    for (let i = 1; i <= pageCount; i++) {
        doc.setPage(i);
        doc.setFontSize(7);
        doc.text(
            `Page ${i} of ${pageCount}`,
            pageWidth - margin - 40,
            doc.internal.pageSize.height - 10
        );
    }

    doc.save('use-case.pdf');
}

document.addEventListener('DOMContentLoaded', () => renderUseCaseTable(useCaseData));
</script>
</body>
</html>